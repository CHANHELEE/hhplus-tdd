

# TDD WITH Kotlin 

---

### BASIC
1. 주어진 4가지 기능에 대한 단위 테스트 작성
    - [x]  `*특정 유저의 포인트를 조회하는 기능을 작성*`
    - [x]  `*특정 유저의 포인트 충전/이용 내역을 조회하는 기능을 작성`*
    - [x]  `*특정 유저의 포인트를 충전하는 기능을 작성*`
    - [x]  `*특정 유저의 포인트를 사용하는 기능을 작성*`
1. 주어진 4가지 기능에 대한 단위 테스트 작성
    - [x]  `*특정 유저의 포인트를 조회하는 기능을 작성*`
    - [x]  `*특정 유저의 포인트 충전/이용 내역을 조회하는 기능을 작성`*
    - [x]  `*특정 유저의 포인트를 충전하는 기능을 작성*`
    - [x]  `*특정 유저의 포인트를 사용하는 기능을 작성*`

### Advanced
1. 심화
   - [x]  동일한 사용자에 대한 동시 요청이 정상적으로 처리될 수 있도록 개선
   - [x]  주어진 4가지 기능에 대한 통합 테스트 작성
   - [x]  선택한 언어에 대한 동시성 제어 방식 및 각 적용의 장/단점을 기술한 보고서 작성 ( README.md )
---
## 동시성 제어 방식 및 각 적용의 장단점

### 1. 동시성 제어 방식


| 항목        | Semaphore                                        | Mutex |
|-----------|--------------------------------------------------| --- |
| **정의**    | 카운터 기반 동기화 도구로, 지정된 개수만큼의 스레드가 동시에 접근할 수 있음      | 상호 배제를 위한 락으로, 한 시점에 하나의 스레드만 임계 구역에 접근 가능 (Semaphor(1) 과 같은 의미) |
| **동작 원리** | 내부 카운터를 이용해 접근 허용. 스레드가 자원에 접근 시 카운터 감소, 반환 시 증가 | 락을 획득한 스레드만 자원에 접근하며, 사용 후 반드시 락을 해제해야 함 |
| **장점**    | - 여러 스레드가 제한된 자원에 동시에 접근할 수 있어 유연함 <br>  - 자원 풀 관리에 적합        | - 구현이 단순하고 오버헤드가 낮음 <br>- 자원에 대한 완전한 배제 효과 제공 |
| **단점**    | - 잘못 구성 시 데드락, 우선순위 역전 등의 문제가 발생할 수 있음 <br> - 구현 및 사용이 복잡함        | - 한 번에 하나의 스레드만 접근 가능하여 병렬 처리가 어려움<br>- 데드락 발생 위험 존재 |
| **사용사례**  | - 여러제한된 수의 자원 접근 제어 (예: 데이터베이스 커넥션 풀, 리소스 풀 관리 등)        | - 단일 자원 보호 (예: 공유 변수, 파일 접근 제어 등) |

- 자원에 대한 완전한 배제 효과 제공 |
  | **단점** | - 잘못 구성 시 데드락, 우선순위 역전 등의 문제가 발생할 수 있음
- 구현 및 사용이 복잡함 | - 한 번에 하나의 스레드만 접근 가능하여 병렬 처리가 어려움<br>- 데드락 발생 위험 존재 |
  | **사용 사례** | 제한된 수의 자원 접근 제어 (예: 데이터베이스 커넥션 풀, 리소스 풀 관리 등) | 단일 자원 보호 (예: 공유 변수, 파일 접근 제어 등) |
- 해당 프로젝트에서는 사용자 포인트에 대한 동시성 제어가 필요 하고, 사용자 포인트에 대해 하나의 스레드만 락을 획득해야 하기 때문에 Mutex 방식 사용.

### 2. Kotlin 에서 사용자 포인트  동시성 제어를 위해 사용될 수 있는 적용 Mutex 기술
#### 1. Syncronized
-  synchronized 블록이나 메서드 내에서는
   한 시점에 하나의 스레드만 실행될 수 있어, 경쟁 상태(race condition)를 방지.
   
    ```kotlin
    // @Synchronized 애노테이션을 사용하면 JVM 레벨에서 
    // 해당 메서드가 동기화되어 한 번에 하나의 스레드만 접근할 수 있음.
    class Counter {
        private var count = 0
        
        @Synchronized
        fun increment() {
            count++
        }
        
        @Synchronized
        fun getCount(): Int {
            return count
        }
    }
    ```
    ```kotlin
    //synchronized 함수를 사용하여 특정 객체(lock)를 기준으로 임계 영역을 설정
    class Counter {
        private var count = 0
        private val lock = Any()
            
        fun increment() {
            synchronized(lock) {
                count++
            }
        }
            
        fun getCount(): Int {
            return synchronized(lock) {
                count 
            }
        }
    }
    ```

#### 2. ConcurrentHashMap

 - hashtable 의 단점을 보완 하여 Multi thred 환경에서 사용 가능 하도록 구현됨


   | **항목** | **설명** |
      | --- | --- |
   | 스레드 안전 | 내부적으로 세밀한 동기화 메커니즘(세그먼트 기반 잠금 또는 CAS, 락 프리 알고리즘)을 사용하여 여러 스레드가 동시에 접근해도 안전하게 동작함. |
   | 동시성 성능 | 읽기 작업은 대부분 락 없이 진행되고, 쓰기 작업의 경우에도 전체 맵이 아닌 일부 버킷이나 노드에 대해서만 잠금을 적용하여 높은 동시성 및 성능을 보장함. |
   | null 값 미지원 | null 키와 null 값을 허용하지 않음. 이는 null을 사용했을 때 발생할 수 있는 모호성을 방지하기 위한 설계 결정임. |
   | 내부 구조 (Java 7 vs Java 8) | - Java 7 이하: 맵을 여러 세그먼트(Segment)로 분할하여 각 세그먼트에 별도의 락을 걸어 동시성 제어- Java 8 이상: 세그먼트 개념을 제거하고, 대신 노드 기반의 락과 CAS 연산, 그리고 필요 시 동기화를 통해 효율적으로 동시성을 관리함 |
   | 사용 사례 | 다중 스레드 환경에서 캐시, 공유 데이터 구조, 빈번한 읽기/쓰기가 요구되는 시스템 등에서 효과적으로 사용됨. |
---

#### 3. ReenterantLock :멀티스레드 환경에서 사용되는 동기화 메커니즘 중 하나로, 같은 스레드가 이미 획득한 락을 다시 획득할 수 있도록 해준다. 이 기능은 특히 한 스레드 내에서 여러 메서드가 서로 호출되며 동일한 공유 자원에 접근할 때 데드락을 방지하는 데 유용함

---
#### 4.  Mutex: Kotlin의 Mutex는 코루틴 환경에서 안전하게 공유 자원에 접근할 수 있도록 설계된 상호 배제(mutual exclusion) 도구이다. 스레드를 블로킹하지 않고 코루틴을 일시 중단(suspend)시킴으로써 비동기 코드에서 동기화를 지원한다.



| **특징** | **설명** |
  | --- | --- |
| 비블로킹 동작 | 락을 획득할 수 없으면 해당 코루틴은 스레드를 차단하지 않고 일시 중단되며, 락이 해제되면 재개됩니다. |
| withLock 확장 함수 | withLock를 사용하면 락의 획득과 해제를 안전하게 처리할 수 있어 코드가 간결하고 예외 상황에서도 락이 제대로 해제됩니다. |
| 비재진입성 | 동일 코루틴이 같은 Mutex를 다시 획득하려 할 경우 데드락이 발생할 수 있으므로, 중첩된 락 획득이 필요한 경우에는 별도의 전략을 고려해야 합니다. |
| 코루틴 친화적 | 코루틴 환경에서 안전하게 공유 자원에 접근할 수 있도록 설계되어, 비동기 프로그래밍에서의 동기화 문제를 효과적으로 해결할 수 있습니다. |
    
   ---


### **ReenterantLock  vs syncronized**

| **항목** | **ReentrantLock** | **synchronized** |
| --- | --- | --- |
| 선언 위치 | 코드 내 명시적으로 객체 생성 | 키워드로 메서드 또는 블록에 선언 |
| 락 해제 방식 | unlock() 호출 필요 (명시적으로 해제) | 블록/메서드 종료 시 자동 해제 |
| 공정성(Fairness) 설정 | 생성자에서 설정 가능 (new ReentrantLock(true)) | 불가능 (항상 비공정) |
| 재진입 가능 여부 | 가능 | 가능 |
| 인터럽트 처리 | lockInterruptibly()로 인터럽트 응답 가능 | 인터럽트 처리 불가 |
| 타임아웃 설정 | tryLock(timeout, unit)으로 가능 | 불가능 |
| 조건 변수(Condition) 지원 | newCondition()으로 지원 | wait()/notify()로 제한적 지원 |
| 성능 | 많은 스레드가 경쟁할 때 더 유리할 수 있음 | 간단한 상황에서는 더 간결하고 빠름 |
| 사용 복잡도 | 복잡함 (try-finally와 unlock 필수) | 간단함 |

---

### 선택 기술

- **ConcurrentHashMap + ReenterantLock**
    - 선택이유 : 사용자 별로 lock 을 걸어야 하고 락요청 간의 공정성을 지켜야 하기 때문에 해당 기술 조합을 선택함.
    - Why not ConcurrentHashMap + kotlin Mutex ? : Mutex 는 코루틴 친화적이며 one thread per request 라는 spring mvc 의 구조 때문에 사용자 포인트 충전/사용시 해당 기능을 사용하기 적합하지 않다고 판단함.
